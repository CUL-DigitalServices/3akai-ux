/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

// This module (along with its associated assets) implements a document
// preview widget. The widget displays the content of an uploaded
// document as individual pages within a section of the web page. It
// provides controls to allow users to advance to specific document
// pages and to zoom in or out to show detail. The widget also supports
// a full-screen mode with browsers that provide the HTML5 full screen
// API.
//
// ## Creating a Module
//
// The module's creation function accepts three parameters
//
// * `uid`: A unique identifier for this particular object. (In general,
//   a web page may include multiple instances of any particular
//   widget, thought this may be less likely for the document
//   preview widget. The `uid` parameter is passed to all widgets,
//   however, to provide a unique ID.)
// * `showSettings`: Not currently used by this widget.
// * `widgetData`: Information about the document to preview. The widget
//   uses several properties of this object:
//   * `id`: Unique identifier for the document to preview.
//   * `latestRevisionId`: Unique identifier for the latest revision of
//     the document. For now, that's the one we're previewing.
//   * `previews.pageCount`: Total number of pages in the document.
//   * `signature.signature`: Digital signature that grants access to the
//     document.
//   * `signature.expires`: Time at which signature (granting access) expires.
//   * `signature.lastModified`: Last modification time of signature that
//     grants access to document.
//
// ## Removing a Module
//
// Although the standard OAE widget doesn't normally include a `delete`
// method, we want to be good citizens and at least provide the option
// to clean up after ourselves. If the `uid` parameter is undefined,
// then we'll take that as a request to delete the widget. The actual
// deletion would be handled by the widget loader, but we do need to
// clean up some stuff that the loader won't know about.
//
// ## API Dependencies
//
// The module relies on the OAE core API to deliver the actual document
// preview content. That content includes several CSS style sheets to
// inject into the web page, as well as HTML for the document pages. All
// API requests include signature parameters added as a query string,
// e.g.,
//
//     ?signature={sig}&expires={exp}&lastmodified={mod}
//
// where
//
// * `{sig}` is the `signature.signature` property of the `widgetData`.
// * `{exp}` is the `signature.expires` property of the `widgetData`.
// * `{mod}` is the `signature.lastModified` property of the `widgetData`.
//
// The extra CSS style sheets are
//
// * `/api/content/{docId}/revisions/{revId}/previews/base.css`
// * `/api/content/{docId}/revisions/{revId}/previews/fancy.css`
// * `/api/content/{docId}/revisions/{revId}/previews/lines.css`
//
// where
//
// * `{docId}` is the unique identifier for the document (the `id`
//   property of `widgetData`.
// * `{revId}` is the identifier for the latest revision (the
//   `lastRevisionId` property of `widgetData`.
//
// The document's pages are themselves accessed via the API as
//
// * `/api/content/{docId}/revisions/{revId}/previews/page.{pageNum}.html`
//
// where `{pageNum]` is the specific document page required.
//
// ## Document Format
//
// TDB

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    // ## Constants

    // We define sensible (well, as sensible as possible) defaults
    // for all the parameters and options that the widget requires.
    // If/when there's a more robust error handling framework in
    // place, we should probably re-visit this approach and throw
    // an error when a required property isn't present. For now,
    // though, throwing an error wouldn't accomplish anything
    // useful so we'll muddle along.
    var DEFAULTS = {
        showSettings: {},
        widgetData:   {
            id: 0,
            latestRevisionId: 0,
            previews: {
                pageCount: 0
            },
            signature: {
                signature: '',
                expires:   '',
                lastModified: ''
            }
        }
    };
    
    // What zoom levels do we support as an array of floating
    // point values. A value of 1.0 is equivalent to a zoom
    // level of 100%. The array should be sorted in order of
    // increasing zoom levels.
    var ZOOMLEVELS = [0.50, 0.75, 0.90, 1.00, 1.10, 1.25, 1.5, 2.00];
    var WIDGETCLASS = 'documentpreview-container';

    // ## Private Attributes

    // More information on individual attributes when they're
    // initialized in the `init()` function.
    var options,
        zoomindex,
        pagenum,
        rootel,
        container,
        toolbar = {},
        styleSheets = [];


    // ## Private Member Functions

    // `getFirstClast()` is a convenience function to find the first
    // element with a given class within the container. It returns
    // `null` if no such element exists.
    var getFirstClass = function(className) {
        var elem = container.getElementsByClassName(className)
        return elem ? elem[0] : null;
    };

    // `updateToolbar()` updates the toolbar controls to reflect
    // the current widget state.
    var updateToolbar = function() {

        // What page are we currently viewing?
        if (toolbar.pageNumber) {
            toolbar.pageNumber.textContent = pagenum;
        }
        // Set the total page count in the toolbar. In theory this
        // should only be needed once, but just in case we ever
        // support dynamic documents (e.g. live edits or annotations)
        // go ahead and update it as well.
        if (toolbar.totalPages) {
            toolbar.totalPages.textContent = options.widgetData.previews.pageCount;
        }
    };

    // `signUrl()` adds the signature parameters to a URL.
    // Its input is the base URL, and it returns the augmented URL.
    // Note that we're blithely assuming the appropriate properties
    // exist in the `options` object. (We defined defaults, so they
    // should be present, even if they're not exactly functional.)

    var signUrl = function(baseUrl) {
        return baseUrl
            + '?signature=' + options.widgetData.signature.signature
            + '&expires=' + options.widgetData.signature.expires
            + '&lastmodified=' + options.widgetData.signature.lastModified;
    };

    // ### addStyles
    //
    // `addStyles()` adds the contents of a style sheet to the
    // document. It returns a reference to the newly added node
    // (which can be used to delete the added styles).

    var addStyles = function(styles) {

        // Direct DOM manipulation is fastest and most widely
        // supported, so we'll use it to create a style node.
        var cssNode = document.createElement('style');
        cssNode.type = 'text/css';

        // To add the actual styles, we handle IE first (of course)
        // since it's unique.
        if (cssNode.styleSheet) {
            cssNode.styleSheet.cssText = styles;
        } else {
            // Everyone else lets us just append the styles to the
            // node. Note that (all/some?) versions of Chrome don't
            // support innerHTML like everyone else so we'll go with
            // a plain old text node.
            cssNode.appendChild(document.createTextNode(styles));
        }

        // Styles are added to the head of the document. All
        // modern browsers support `document.head` but we'll
        // be nice and handle older browsers as well.
        var head = document.head || document.getElementsByTagName('head')[0];
        head.appendChild(cssNode);

        // Return the newly added style sheet node so it can
        // be easily removed.
        return cssNode;
    };

    // ### removeStyles
    //
    // `removeStyles()` removes a previously added style sheet
    // node from the DOM.

    var removeStyles = function(cssNode) {
        cssNode.parentNode.removeChild(cssNode);
    };

    // ### addStyleSheet
    //
    // `addStyleSheet()` adds an external CSS style sheet to the
    // page. Its parameter is an object that includes a `url`
    // property. When the style sheet is loaded, the `cssNode`
    // property of this object is set to the node that is
    // added to the DOM.

    var addStyleSheet = function(styleSheetObj) {
        
        // Note that we're grabbing the stylesheet directly
        // using a `$.ajax()` call rather than simply inserting
        // an external link into the DOM, e.g.
        //
        //     $('<link>')
        //         .attr({
        //             rel:  'stylesheet',
        //             type: 'text/css',
        //             href: styleSheetObj.url
        //         })
        //         .appendTo('head');
        //
        // The benefits of the `$.ajax()` approach include:
        //
        // 1. We'll know if there's an error in retrieving the
        //    the stylesheet so we can take corrective action
        //    if possible.
        // 2. We'll have easy access to the style rules from
        //    JavaScript so we can do fancy stuff like adjust
        //    the scrolling threshold based on page size(s)
        //    defined in the CSS.
        // 3. We can easily mock out the stylesheets for unit
        //    testing.

        $.ajax({
                url: styleSheetObj.url,
                dataType: 'text'
            })
            .done(function (response) {
                styleSheetObj.styles = response;
                styleSheetObj.cssNode = addStyles(response);
            })
            .fail(function() {
                // Here is where we could take corrective
                // action or indicate the error, if appropriate.
                // For now, we'll simply go with unstyled
                // content.
                styleSheetObj.styles = '';
                styleSheetObj.cssNode = null;
            })
    };

    // ### removeStyleSheet
    //
    // `removeStyleSheet()` removes an external CSS style sheet
    // from the page. Its parameter is an object that includes
    // a `cssNode` property that references the added node.

    var removeStyleSheet = function(styleSheetObj) {
        if (styleSheetObj.cssNode) {
            removeStyles(styleSheetObj.cssNode);
        }
        styleSheetObj.cssNode = null;
        styleSheetObj.styles = '';
   };

    // ### createStyleSheetUrl
    //
    // `createStyleSheetUrl()` constructs a full URL to access
    // a widget style sheet given the filename.

    var createStyleSheetUrl = function(filename) {
        return signUrl(
            '/api/content/' + options.widgetData.id +
            '/revisions/' + options.revisionId +
            '/previews/' + filename
        );
    };

    // ### init
    //
    // `init()` initializes the widget object. Its parameters
    // are the unique widget identifer and the widgetData object
    // passed on object creation

    var init = function(uid, showSettings, widgetData) {

        // Save local copies of the input parameters
        options = $.extend(true, DEFAULTS,
            {uid: uid},
            {showSettings: showSettings},
            {widgetData: widgetData}
        );

        // Until there's an API to get anything else, we'll use
        // the last revision ID as the one to display.
        options.revisionId = options.widgetData.latestRevisionId;

        // Cache the element that's acting as the root
        // for the widget. This is where the unique identifier
        // comes into play. The widget will be installed inside
        // of an HTML element with the unique ID as an `id`
        // attribute.
        rootel = document.getElementById(uid);

        // If we couldn't fine the root element, then something
        // has probably gone wrong. Throwing an error at this
        // point won't do anything useful though. Instead, we'll
        // try to continue by grabbing the `<html>` tag as the
        // root element. So long as the appropriate container is
        // present somewhere in the document (and there's only
        // one), this will actually work.
        if (!rootel) {
            document.getElementsByTagName('html')[0];
        }

        // The widget itself should be created within this uniquely
        // identified root element. Note that we use a class name
        // for the container to allow for the possibility of multiple
        // document preview widgets on the page.
        container = rootel.getElementsByClassName(WIDGETCLASS);

        // If there's not a container element, then we're completely
        // hosed, so bail. Otherwise, use the first one found. (There
        // should only be one. If a robust error framework is in
        // place, it might be appropriate to verify this and throw
        // an error if length > 1.)
        if (!container) {
            return;
        }
        container = container[0];

        // Cache other elements on the page that we'll need to access
        // frequently.
        toolbar.zoomIn     = getFirstClass('zoom-in');
        toolbar.zoomOut    = getFirstClass('zoom-out');
        toolbar.fullScreen = getFirstClass('full-screen');
        toolbar.prevPage   = getFirstClass('prev-page');
        toolbar.pageNumber = getFirstClass('page-num');
        toolbar.totalPages = getFirstClass('page-count');
        toolbar.nextPage   = getFirstClass('next-page');

        // Initialize the variables that track toolbar options, and
        // then update the toolbar itself.
        zoomindex = _(ZOOMLEVELS).indexOf(1.0);
        pagenum = 1;
        updateToolbar();

        // Rendering the preview correctly relies on several
        // additional CSS style sheets. We can keep track of them
        // here in case there's ever a need to remove them (e.g.
        // if the widget is removed from the page without a page
        // refresh).
        styleSheets.push({url: createStyleSheetUrl('base.css')});
        styleSheets.push({url: createStyleSheetUrl('fancy.css')});
        styleSheets.push({url: createStyleSheetUrl('lines.css')});

        // Now we can go ahead and start adding the style sheets
        // to the page.
        _(styleSheets).each(function(styleSheetObj) {
            addStyleSheet(styleSheetObj);
        })
        
    };

    // ### remove
    //
    // `remove()` prepares the widget for removal from the page.

    var remove = function() {
        // Remove the CSS style sheets we added to the page.
        _(styleSheets).each(function(styleSheetObj) {
            removeStyleSheet(styleSheetObj);
        });
    };

    // ## Returned Object
    //
    // Return the object that controls the document preview.

    return function(uid, showSettings, widgetData) {

        if (_(uid).isUndefined()) {
            remove();
        } else {
            // We've got a `uid` defined, so go ahead and
            // initialize the widget.
            init(uid, showSettings, widgetData);
        }
        return {
            delete: remove
        }
    };
});
