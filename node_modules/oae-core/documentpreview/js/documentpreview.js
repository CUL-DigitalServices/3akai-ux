/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * This module (along with its associated assets) implements a document
 * preview widget. The widget displays the content of an uploaded
 * document as individual pages within a section of the web page. It
 * provides controls to allow users to advance to specific document
 * pages and to zoom in or out to show detail. The widget also supports
 * a full-screen mode with browsers that provide the HTML5 full screen
 * API.
 *
 * This module relies on the [HTML5 full screen API]
 * (https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html) and [CSS3
 * scale transforms](http://dev.w3.org/csswg/css-transforms/#transform).
 * Both features combined have implications throughout
 * the code below. Without discussing the specifics of the code (so
 * this documentation doesn't have to be updated as the code changes),
 * understanding some of the particular implications of these features
 * might be helpful.
 *
 * ## Scale Transforms Use "Virtual" Pixels
 *
 * When an element has a `scale` transform applied, the number of pixels
 * that the element uses on the screen changes according the scale
 * value. For example, an element with a normal width of 100 pixels,
 * when scaled at a value of 2.0, will take up 200 pixels on the user's
 * screen. The properties of that element, however, will still show
 * its width as 100 pixels. This property effects other elements in
 * the document such as overflow scrolling on a container element.
 *
 * To see this more clearly, consider the following example:
 *
 *     <div id='container' style='width:150px; overflow:auto;'>
 *         <div id='contained' style='width:200px;'>
 *             Content
 *         </div>
 *     </div>
 *
 * Since the inner (`#contained`) element's width is larger than
 * the outer (`#container`), the browser will activate horizontal
 * scrolling as expected.
 *
 * Now consider this alternative:
 *
 *     <div id='container' style='width:150px; overflow:auto;'>
 *         <div id='contained' style='width:100px; transform:scale(2.0);'>
 *             Content
 *         </div>
 *     </div>
 *
 * As above, the inner element has a width of 200 pixels. Because
 * that width is achieved via scaling, however, its width property
 * is only 100 pixels. The browser will not activate horizontal
 * scroll bars; instead, the right-most part of the inner element
 * will "break out" of the container. That may not be the desired
 * behavior.
 *
 * ## Fixing the Overflow Problem
 *
 * As of this writing there is no pure CSS method to fix this
 * overflow problem; however, it is possible with JavaScript.
 * The solution is to embed the contained object within a
 * wrapper and set the size explicitly on that wrapper. In
 * effect, the resulting markup looks like:
 *
 *     <div id='container' style='width:150px; overflow:auto;'>
 *         <div id='wrapper' style='width:200px;'>
 *             <div id='contained' style='width:100px; transform:scale(2.0);'>
 *                 Content
 *             </div>
 *         </div>
 *     </div>
 *
 * Whenever the JavaScript changes the scale value of the inner
 * element (`#contained`) it simultaenously changes the explicit
 * width of the wrapper. This does mean, however, that the
 * JavaScript has to know the natural (unscaled) width of the
 * inner content.
 *
 * ## Getting the Width of Contained Content
 *
 * If the inner content is delivered from an external source (e.g.
 * an API), the JavaScript code may not know, _a priori,_ the
 * content's width. And if the content isn't guaranteed to have
 * a single parent element, there isn't a clean and reliable way
 * to query the content to determine its width. However, it is
 * possible to find the width of the content. Embed the content
 * within a `<div>` with a `display` property of `inline-block`
 * and then query the width of that `<span>`. The markup would
 * look like:
 *
 *     <div id='container' style='width:150px; overflow:auto;'>
 *         <div id='wrapper'>
 *             <div id='inner-wrapper' style='display:inline-block;'>
 *                 <div id='contained1' style='width:100px;'>
 *                     Content
 *                 </div>
 *                 <div id='contained2' style='width:120px;'>
 *                     More Content
 *                 </div>
 *             </div>
 *         </div>
 *     </div>
 *
 * The following code will correctly return the value `120` for
 * the width of the overal content:
 *
 *     $('#inner-wrapper').width()  // --> 120
 *
 * Note, though, that wrapping the content in this manner can
 * effect how the content displays. In particular, if the content
 * is a single `<div>` with an explicit width, it may try to
 * use the common `margin-right: auto` and `margin-left: auto`
 * properties to force a centered vertical alignment. Using the
 * structure above breaks that alignment technique.
 *
 * ## Restoring a Centered Vertical Alignment
 *
 * Restoring a centered vertical alignment requires some
 * additional JavaScript code. There are several possible
 * approaches. One that is relatively simple is to shift
 * the position of the inner `<span>`. Make sure that it has
 * a `position` property of `relative` and then adjust the
 * `left` property appropriately to achieve the vertical
 * alignment.
 *
 * When using this approach, be aware that pages based
 * on responsive web design may change the widths of
 * various elements based on the window size. If these
 * widths change, the calculated position may need to
 * change as well. Watching for window resize events
 * will provide a trigger for recalculation. Users
 * entering and exiting HTML5 full screen mode may
 * also change the calculation, so hooking the full
 * screen API events may also be appropriate.
 *
 */

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    return function(uid, showSettings, widgetData) {


        ///////////////
        // Constants //
        ///////////////

        // Supported zoom levels listed in sorted order
        var ZOOMLEVELS = [50, 75, 90, 100, 110, 125, 150, 200];

        // How long to give the browser to calculate layouts
        var DOMLAYOUTDELAY = 300;

        // How long to keep checking in case browser is slow
        var DOMLAYOUTCHECKMAX = 10000;

        // How close to page top before page is "in view"
        var PAGEVIEWCUSION = 1;


        ////////////////////////
        // Instance Variables //
        ////////////////////////

        // Variable that will keep track of the current interaction
        // state of the widget
        var state = {
            'zoomLevel': 100,
            'pageNumber': 1
        };

        // Variable to store the array of pages in the document
        var pages = [];

        // Number of pages loaded so far
        var lastPageLoaded = 0;

        // Which pages are currently in view
        var pagesInView = [];

        // Are we trying to catch up to the user?
        var catchingUp = false;


        ///////////////////////////////
        // Cached Element References //
        ///////////////////////////////

        var $rootel = $('#' + uid);
        var $container = $('#documentpreview-container', $rootel);
        var $content = $('.documentpreview-content', $container);
        var $zoomIn = $('.documentpreview-zoom-in', $container);
        var $zoomOut = $('.documentpreview-zoom-out', $container);
        var $fullScreen = $('.documentpreview-full-screen', $container);
        var $prevPage = $('.documentpreview-page-prev', $container);
        var $pageNumber = $('.documentpreview-page-num', $container);
        var $totalPages = $('.documentpreview-page-count', $container);
        var $nextPage = $('.documentpreview-page-next', $container);


        /////////////////////
        // Full Screen API //
        /////////////////////

        /**
         * Does the browser support HTML5 full screen API?
         *
         * @return  {Boolean}  true if full screen is available
         * @see https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html
         */
        var supportsFullscreen = function() {
            var el = $('html')[0];
            return el.requestFullscreen ||
                   el.mozRequestFullScreen ||
                   el.webkitRequestFullscreen;
        };

        /**
         * Is HTML5 full screen mode currently active?
         *
         * @return  {Boolean}  true if full screen is active
         */
        var isFullscreenActive = function() {
            var el = $('html')[0];
            if (el.requestFullscreen) {
                return document.fullScreenElement;
            } else if (el.mozRequestFullScreen) {
                return document.mozFullScreenElement;
            } else if (el.webkitRequestFullscreen) {
                return document.webkitFullScreenElement;
            } else {
                return false;
            }
        };

        /**
         * Display an element in full screen mode
         *
         * @param  {Object}  $el  jQuery-wrapped element to render in full screen
         */
        var activateFullscreen = function($el) {
            var htmlEl = $el[0];
            if (htmlEl.requestFullscreen) {
                htmlEl.requestFullscreen();
            } else if (htmlEl.mozRequestFullScreen) {
                htmlEl.mozRequestFullScreen();
            } else if (htmlEl.webkitRequestFullscreen) {
                htmlEl.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        };


        ////////////////////////////////
        // CSS Transform Manipulation //
        ////////////////////////////////

        /**
         * Set CSS transform origin for an element.
         *
         * @param  {Object}  $htmlEl  jQuery-wrapped element to set
         * @param  {String}  origin   origin value to set
         */
        var cssTransformOrigin = function($htmlEl, origin) {
            $htmlEl.css('-webkit-transform-origin', origin)
                   .css('-moz-transform-origin', origin)
                   .css('-ms-transform-origin', origin)
                   .css('transform-origin', origin);
        };

        /**
         * Apply CSS transforms to an element. (Note that successive
         * calls to this function are not additive. Rather, they
         * replace the value(s) from prior calls.)
         *
         * @param  {Object}  $htmlEl     jQuery-wrapped element to recieve transforms
         * @param  {Object}  transforms  hash of transforms to apply
         */
        var cssTransform = function($htmlEl, transforms) {
            var transform = _.reduce(transforms, function(arr, value, key) {
                    arr.push(key + '(' + value + ')');
                    return arr;
                }, []).join(' ');
            $htmlEl.css('-webkit-transform', transform)
                   .css('-moz-transform', transform)
                   .css('-ms-transform', transform)
                   .css('transform', transform);
        };


        ///////////////////////////////////
        // OAE API Convenience Functions //
        ///////////////////////////////////

        /**
         * Create a full URL for a document preview component
         *
         * @param   {String}  baseURL  base URL for the component (e.g. "styles.css")
         * @return  {String}           complete path to component
         */
        var constructDocumentPreviewURL = function(baseURL) {
            return '/api/content/' + widgetData.id +
                   '/revisions/' + widgetData.latestRevisionId +
                   '/previews/' + baseURL +
                   '?signature=' + widgetData.signature.signature +
                   '&expires=' + widgetData.signature.expires +
                   '&lastmodified=' + widgetData.signature.lastModified;
        };


        /////////////
        // Toolbar //
        /////////////

        /**
         * Refresh the Toolbar view
         */
        var refreshToolbar = function() {
            var zoomIndex = _.indexOf(ZOOMLEVELS, state.zoomLevel);
            var pageNumber = state.pageNumber;
            var pageCount = widgetData.previews.pageCount;

            // Enable/disable controls as appropriate
            $zoomOut.prop('disabled', (zoomIndex <= 0));
            $zoomIn.prop('disabled', (zoomIndex >= (ZOOMLEVELS.length - 1)));
            $nextPage.prop('disabled', (pageNumber >= pageCount));

            // Indicate the page that is currently showing
            $pageNumber.val(pageNumber);
        };

        /**
         * Adjust display for a change in zoom level
         */
        var changeZoom = function() {
            /**
             * We need to adjust the scroll position after rescaling
             * the pages. Remember where we are now.
             */
            var currentPage = pages[state.pageNumber-1];
            var currentTop = currentPage.$el.position().top;
            var currentZoom = $content.attr('data-zoom');

            // Scale all the pages
            _.each(pages, zoomPage);
            $content.attr('data-zoom', state.zoomLevel);

            // Restore the scroll position
            var newTop = (currentTop / currentZoom) * state.zoomLevel;
            $content.scrollTop($content.scrollTop() + currentPage.$el.position().top - newTop);
        };

        /**
         * Validate and accept an input page number
         */
        var pageInput = function() {
            /**
             * Convert input to a number. By prepending a `+`
             * we ensure that mixed letter/numbers are converted
             * to NaN (which is different from `parseInt()`.
             */
            var pageNumber = +$pageNumber.val();
            /**
             * If the number the user is entering isn't valid,
             * we ignore the changes.
             */
            if ( !(_.isNaN(pageNumber)) &&
                  (pageNumber >= 1) &&
                  (pageNumber <= widgetData.previews.pageCount) &&
                  (pageNumber !== state.pageNumber) ) {

                state.pageNumber = pageNumber;
                /**
                 * Before we load the requested page, we must make
                 * sure that all prior pages are in the DOM.
                 * Otherwise the scroll position of the page might
                 * change if those prior pages are later loaded.
                 */
                waitForPriorPages(pageNumber).done(function() {
                    scrollToPage(pages[pageNumber-1]);
                });
            }
        };

        /**
         * Toolbar event handlers
         */
        $zoomIn.on('click', function() {
            var zoomIndex = _.indexOf(ZOOMLEVELS, state.zoomLevel);
            if (zoomIndex < (ZOOMLEVELS.length - 1)) {
                state.zoomLevel = ZOOMLEVELS[++zoomIndex];
                refreshToolbar();
                changeZoom();
            }
        });

        $zoomOut.on('click', function() {
            var zoomIndex = _.indexOf(ZOOMLEVELS, state.zoomLevel);
            if (zoomIndex > 0) {
                state.zoomLevel = ZOOMLEVELS[--zoomIndex];
                refreshToolbar();
                changeZoom();
            }
        });

        $fullScreen.on('click', function() {
            activateFullscreen($content);
        });

        $prevPage.on('click', function() {
            if (state.pageNumber > 1) {
                state.pageNumber--;
                refreshToolbar();
            }
            /**
             * Always execute the scrollTo, even if user
             * is already on page 1, so that the user can
             * easily get to the top of the document.
             */
            scrollToPage(pages[state.pageNumber-1]);
        });

        $nextPage.on('click', function() {
            if (state.pageNumber < widgetData.previews.pageCount) {
                state.pageNumber++;
                refreshToolbar();
                scrollToPage(pages[state.pageNumber-1]);
            }
        });

        $pageNumber.on('input', _.debounce(function() {
            /**
             * Make sure that the element still has focus. If not,
             * then the user has already "moved on" and the change
             * event will have take care of the input. We're just
             * late to the party.
             *
             * Note that we don't want to refresh the toolbar for
             * the 'input' event since the user is doing that for us.
             */
             if ($pageNumber.is(':focus')) {
                 pageInput();
             }
        }, 500));

        $pageNumber.on('change', function() {
            /**
             * Handle any input changes to take care of the case
             * where the input event is still debouncing.
             */
            pageInput();
            /**
             * We need to refresh the toolbar in case the user
             * entered an invalid value. Now's the time to show
             * any corrections.
             */
            refreshToolbar();
        });


        //////////////////////
        // Document Content //
        //////////////////////

        /**
         * Start the process of loading a document page
         *
         * @param  {Object}  page  page to load
         */
        var loadPage = function(page) {
            // Make sure there isn't already a request in progress
            if (!page.deferred) {

                lastPageLoaded = Math.max(lastPageLoaded, page.pageNumber);

                // Create the container for the page and insert in DOM
                page.$el = $($.trim(oae.api.util.template().render(
                    '#documentpreview-content-page-template',
                    {'pageNumber': page.pageNumber}
                )));
                $content.append(page.$el);

                // Show a loading indicator while we wait
                oae.api.util.template().render(
                    '#documentpreview-content-page-loading-template',
                    {},
                    page.$el
                );

                // Request the page
                page.deferred = $.ajax({
                    'url': constructDocumentPreviewURL('page.' + page.pageNumber + '.html'),
                    'dataType': 'text',
                    'success': function(response) {

                        // Replace loading indicator with content
                        oae.api.util.template().render(
                            '#documentpreview-content-page-wrapper-template',
                            {'pageContent': response},
                            page.$el
                        );
                        page.$inner = $('.documentpreview-content-page-wrapper-inner', page.$el);
                        page.$outer = $('.documentpreview-content-page-wrapper-outer', page.$el);

                        // If no zooming, we all we need to do is prefetch
                        if (state.zoomLevel === 100) {

                            prefetch();

                        } else {

                            /**
                             * If there is zooming, we need to scale the new page. That means
                             * we have to give the browser time to digest the new content
                             * before we can query for sizing information. In the meantime,
                             * hide the content so it doesn't look weird. Also reset the
                             * deferred object since we're not done yet.
                             */
                            page.$el.css('opacity', '0');
                            page.deferred = $.Deferred();

                            var layoutCheckTime = 0;
                            var checkInterval = setInterval(function() {

                                // Only do this for the configured limit
                                if (layoutCheckTime > DOMLAYOUTCHECKMAX) {

                                    clearInterval(checkInterval);

                                // First time through tentatively show the page
                                } else if (layoutCheckTime === 0) {

                                    zoomPage(page);
                                    page.$el.css('opacity', '');
                                    page.deferred.resolve();

                                // All other times see if first attempt was wrong
                                } else if (page.naturalHeight) {

                                    if ( (page.$inner.css('display') === 'inline-block') &&
                                         (page.$inner.outerHeight(true) !== page.naturalHeight) ) {

                                        // Only correct if page isn't yet in view
                                        updatePagesInView();

                                        if (pagesInView.length &&
                                            (_.last(pagesInView).pageNumber < page.pageNumber)) {
                                            zoomPage(page);
                                        }

                                    }

                                }

                                layoutCheckTime += DOMLAYOUTDELAY;

                            }, DOMLAYOUTDELAY);
                        }
                    }
                });
            }
        };

        /**
         * Wait for loading of all pages ahead of a given page, e.g.
         * to ensure that the scroll position of the given page can
         * be calculated accurately
         *
         * @param  {Number}  pageNumber  number of page to load up to
         */
        var waitForPriorPages = function(pageNumber) {
            // If a wait is already in progress, cancel it
            if (catchingUp) {
                catchingUp.reject();
            }

            catchingUp = $.Deferred();

            var deferreds = [];
            _.each(pages, function(page) {
                if (page.pageNumber < pageNumber) {
                    loadPage(page);
                    deferreds.push(page.deferred);
                }
            });
            $.when.apply($, deferreds).done(function() {
                catchingUp.resolve();
            });
            return catchingUp;
        };

        /**
         * Scroll the content area to a specific page
         *
         * @param  {Object}  page  page to be shown
         */
        var scrollToPage = function(page) {

            // Make sure the page has (or is getting) content
            loadPage(page);

            // Scroll to the page's position (with a little cushion)
            $content.scrollTop($content.scrollTop() +
                               page.$el.position().top -
                               PAGEVIEWCUSION);

            // Prefetch if space is available
            prefetch();
        };

        /**
         * Zoom the page according to the document zoom level
         *
         * @param  {Object}  page  page to be scaled
         */
        var zoomPage = function(page) {
            if (page.$outer && page.$inner) {

                var scale = state.zoomLevel / 100;

                if (state.zoomLevel !== 100) {

                    /**
                     * If we haven't already found the natural height of the page,
                     * do it now (before any zooming). To get it accurately, we
                     * have to convert the inner wrapper to `inline-block`.
                     */
                    page.$inner.css('display', 'inline-block');
                    page.naturalHeight = page.naturalHeight || page.$inner.outerHeight(true);
                    page.$el.css('height', (page.naturalHeight * scale) + 'px');

                } else {

                    page.$el.css('height', '');

                }
                cssTransformOrigin(page.$outer, 'top left');
                cssTransform(page.$outer, {'scale': scale});
                alignPage(page);

                // Prefetch if the zooming opened up space
                prefetch();
            }
        };

        /**
         * Align a page in the middle of its container
         *
         * @param  {Object}  page  page to align
         */
        var alignPage = function(page) {
            if (page.$inner) {
                if (state.zoomLevel === 100) {

                    // No scaling, so just use standard `margin: auto`
                    page.$inner.css({
                        'display': 'block',
                        'left': ''
                    });

                } else {

                    /**
                     * If scaling, we can't rely on `margin: auto`. Instead
                     * change the inner wrapper to conform to the content
                     * width and then retrieve the actual width.
                     */
                    page.$inner.css('display', 'inline-block');
                    var containerWidth = isFullscreenActive() ? $(window).width() : $content.width();
                    var contentWidth = page.$inner.outerWidth(true) * state.zoomLevel / 100;
                    var left;

                    // Manually calculate the position and set it via css
                    // positioning
                    if (contentWidth < containerWidth) {
                        left = (100 / state.zoomLevel) * (containerWidth - contentWidth) / 2;
                    } else {
                        // Page too wide for container, left edge it goes
                        left = 5; // add some space (e.g. for border)
                    }
                    page.$inner.css('left', left + 'px');
                }
            }
        };

        /**
         * Align all pages in the document
         */
        var alignAllPages = function() {
            _.each(pages, alignPage);
        };

        /**
         * See which pages are currently viewable in the container
         */
        var updatePagesInView = function() {

            pagesInView = _.reduce(pages, function(inView, page) {
                var height = page.naturalHeight || page.$el.height();
                if ( page.$el &&
                    ((page.$el.position().top + height) > (0 + PAGEVIEWCUSION)) &&
                    (page.$el.position().top <= $content.height()) ) {
                        inView.push(page);
                    }
                return inView;
            }, []);

        };

        /**
         * Ensure the container is full enough to scroll
         */
        var prefetch = function() {

            // If all pages already loading/loaded, we're done
            if (lastPageLoaded < widgetData.previews.pageCount) {

                // Make sure there's one container's worth of content
                // "below the fold"
                if (($content.prop('scrollHeight') -
                        $content.height() -
                        $content.scrollTop())  <  $content.height()) {

                    loadPage(pages[lastPageLoaded]);

                }
            }

        };

        $content.on('scroll', _.debounce(function() {

            /**
             * See what page user is currently viewing so,
             * if necessary, we can update the toolbar
             */
            updatePagesInView();
            var pageNumber = pagesInView.length ? pagesInView[0].pageNumber : 1;
            if (pageNumber !== state.pageNumber) {
                state.pageNumber = pageNumber;
                refreshToolbar();
            }

            // Prefetch to make sure more content is available
            prefetch();

        }, 50));

        $(window).on('resize', _.debounce(function() {
            alignAllPages();
        }, 50));

        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', alignAllPages);


        ////////////////////
        // Initialization //
        ////////////////////

        // Inject the document-specific style sheets
        _.each(['base.css','fancy.css','lines.css'], function(file) {
            $('head').append('<link rel="stylesheet" href="' +
                             constructDocumentPreviewURL(file) + '"/>');
        });

        // Create the objects for all document pages
        _.each(_.range(widgetData.previews.pageCount), function(index) {
            pages.push({'pageNumber': index + 1}); // Document page numbers start at 1
        });

        // Update the toolbar to reflect initial state
        $totalPages.text(widgetData.previews.pageCount);
        if (supportsFullscreen()) {
            $fullScreen.show();
        }
        refreshToolbar();

        // Set up the content container
        $content.attr('data-zoom', state.zoomLevel);
        scrollToPage(pages[state.pageNumber-1]);

    };
});
