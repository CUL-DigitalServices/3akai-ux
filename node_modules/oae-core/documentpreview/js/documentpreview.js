/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * This module (along with its associated assets) implements a document
 * preview widget. The widget displays the content of an uploaded
 * document as individual pages within a section of the web page. It
 * provides controls to allow users to advance to specific document
 * pages and to zoom in or out to show detail. The widget also supports
 * a full-screen mode with browsers that provide the HTML5 full screen
 * API.
 *
 * This module relies on a couple of (as of this writing) experimental
 * HTML/CSS features, specifically the HTML5 full screen API and CSS3
 * scale transforms. Both features combined have implications throughout
 * the code below. Without discussing the specifics of the code (so
 * this dcoumentation doesn't have to be updated as the code changes),
 * understanding some of the particular implications of these features
 * might be helpful.
 *
 * ## Scale Transforms Use "Virtual" Pixels
 *
 * When an element has a `scale` transform applied, the physical pixels
 * that the element uses on the screen changes according the scale
 * value. For example, an element with a normal width of 100 pixels,
 * when scaled at a value of 2.0, will take up 200 pixels on the user's
 * screen. The properties of that element, however, will still show
 * its width as 100 pixels. This property effects other elements in
 * the document such as overflow scrolling on a container element.
 *
 * To see this more clearly, consider the following example:
 *
 *     <div id='container' style='width:150px;overflow:auto>
 *         <div id='contained' style='width:200px'>
 *             Content
 *         </div>
 *     </div>
 *
 * Since the inner (`.contained`) element's width is larger than
 * the outer (`.container`), the browser will activate horizontal
 * scrolling as expected.
 *
 * Now consider this alternative:
 *
 *     <div id='container' style='width:150px;overflow:auto>
 *         <div id='contained' style='width:100px;transform:scale(2.0)'>
 *             Content
 *         </div>
 *     </div>
 *
 * As above, the inner elements has a width of 200 pixels. Because
 * that width is achieved via scaling, however, its width property
 * is only 100 pixels. The browser will not activate horizontal
 * scroll bars; instead, the right-most part of the inner element
 * will "break out" of the container. That may not be the desired
 * behavior.
 *
 * ## Fixing the Overflow Problem
 *
 * As of this writing there is no pure CSS method to fix this
 * overflow problem; however, it is possible with JavaScript.
 * The solution is to embed the contained object within a
 * wrapper and set the size explicitly on that wrapper. In
 * effect, the resulting markup looks like:
 *
 *     <div id='container' style='width:150px;overflow:auto>
 *         <div id='wrapper' style='width:200px'>
 *             <div id='contained' style='width:100px;transform:scale(2.0)'>
 *                 Content
 *             </div>
 *         </div>
 *     </div>
 *
 * Whenever the JavaScript changes the scale value of the inner
 * element (`.contained`) it simultaenously changes the explicit
 * width of the wrapper. This does mean, however, that the
 * JavaScript has to know the natural (unscaled) width of the
 * inner content.
 *
 * ## Getting the Width of Contained Content
 *
 * If the inner content is delivered from an external source (e.g.
 * an API), the JavaScript code may not know, _a priori,_ the
 * content's width. And if the content isn't guaranteed to have
 * a single parent element, there isn't a clean and reliable way
 * to query the content to determine it's width. However, it is
 * possible to find the width of the content. Embed the content
 * within a `<span>` with a `display` property of `inline-block`
 * and then query the width of that `<span>`. The markup would
 * look like:
 *
 *     <div id='container' style='width:150px;overflow:auto>
 *         <div id='wrapper'>
 *             <span id='inner-wrapper' style='display:inline-block'>
 *                 <div id='contained1' style='width:100px'>
 *                     Content
 *                 </div>
 *                 <div id='contained2' style='width:120px'>
 *                     More Content
 *                 </div>
 *             </span>
 *         </div>
 *     </div>
 *
 * The following code will correctly return the value `120` for
 * the width of the overal content:
 *
 *     $('.inner-wrapper').width()  // --> 120
 *
 * Note, though, that wrapping the content in this manner can
 * effect how the content displays. In particular, if the content
 * is a single `<div>` with an explicit width, it may try to
 * use the common `margin-right: auto` and `margin-left: auto`
 * properties to force a centered vertical alignment. Using the
 * structure above breaks that alignment technique.
 *
 * ## Restoring a Centered Vertical Alignment
 *
 * Restoring a centered vertical alignment requires some
 * additional JavaScript code. There are several possible
 * approaches. One that is relatively simple is to shift
 * the position of the inner `<span>`. Make sure that it has
 * a `position` property of `relative` and then adjust the
 * `left` property appropriately to achieve the vertical
 * alignment.
 *
 * When using this approach, be aware that pages based
 * on responsive web design may change the widths of
 * various elements based on the window size. If these
 * widths change, the calculated position may need to
 * change as well. Watching for window resize events
 * will provide a trigger for recalculation. Users
 * entering and exiting HTML5 full screen mode may
 * also change the calculation, so hooking the full
 * screen API events may also be appropriate.
 *
 */

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    return function(uid, showSettings, widgetData) {


        ///////////////
        // Constants //
        ///////////////

        // What zoom levels do we support, sorted in order of increasing zoom
        // levels.
        var ZOOMLEVELS = [50, 75, 90, 100, 110, 125, 150, 200];

        // How close (in pixels) to get to the bottom of a scrolling container
        // before loading more content.
        var LOADTHRESHOLD = 200;

        var DEFAULTSTATE = {
            zoomlevel: 100,
            pagenum: 1
        };
        
    
        ////////////////
        // Attributes //
        ////////////////

        // Variable that will be used to save the options associated
        // with the widget when it is created.
        var options = $.extend(true, {},
            {uid: uid},
            {showSettings: showSettings},
            {widgetData: widgetData}
        );
        
        // Until there's an API to get anything else, we'll use
        // the last revision ID as the one to display.
        options.revisionId = options.widgetData.latestRevisionId;
        
        // Variable that will keep track of the current interaction
        // state of the widget.
        var state = $.extend(true, {}, DEFAULTSTATE);

        // Variable to store the array of pages in the document
        var pages = [];


        ///////////////////////////////
        // Cached Element References //
        ///////////////////////////////

        var $rootel = $('#' + uid);
        var $container = $rootel.find('#documentpreview-container');
        var $content = $container.find('.documentpreview-content');
        var $zoomIn = $container.find('.documentpreview-zoom-in');
        var $zoomOut = $container.find('.documentpreview-zoom-out');
        var $fullScreen = $container.find('.documentpreview-full-screen');
        var $prevPage = $container.find('.documentpreview-page-prev');
        var $pageNumber = $container.find('.documentpreview-page-num');
        var $totalPages = $container.find('.documentpreview-page-count');
        var $nextPage = $container.find('.documentpreview-page-next');


        ///////////////////////////
        // Convenience Functions //
        ///////////////////////////

        /**
         * Does the browser support HTML5 full screen API?
         * @returns {boolean} true if full screen is available
         */
        var hasFullscreen = function() {
            var el = $('html')[0];
            return el.requestFullscreen ||
                   el.msRequestFullScreen ||
                   el.mozRequestFullScreen ||
                   el.webkitRequestFullscreen;
        };
    
        /**
         * Is HTML5 full screen mode currently active?
         * @returns {boolean} true if full screen is active
         */
        var isFullscreenActive = function() {
            var el = $('html')[0];
            if (el.requestFullscreen) {
              return document.fullScreenElement;
            } else if (el.msRequestFullScreen) {
                return document.msFullScreenElement;
            } else if (el.mozRequestFullScreen) {
                return document.mozFullScreenElement;
            } else if (el.webkitRequestFullscreen) {
              return document.webkitFullScreenElement;
            } else {
                return false;
            }
        };

        /**
         * Display an element in full screen mode
         * @param {object} DOM element to render in full screen
         */
        var activateFullscreen = function(el) {
            if (el.requestFullscreen) {
              el.requestFullscreen();
            } else if (el.msRequestFullScreen) {
                el.msRequestFullScreen();
            } else if (el.mozRequestFullScreen) {
                el.mozRequestFullScreen();
            } else if (el.webkitRequestFullscreen) {
              el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        };

        /**
         * Set CSS transform origin for an element.
         * @param {object} element to set
         * @param {string} origin value to set
         */
        var cssTransformOrigin = function($el, origin) {
            $el.css('-webkit-transform-origin', origin)
               .css('-moz-transform-origin', origin)
               .css('-ms-transform-origin', origin)
               .css('transform-origin', origin);
        };
        
        /**
         * Apply CSS transforms to an element.
         * @param {object} element to recieve transforms
         * @param {object} hash of transforms to apply
         */
        var cssTransform = function($el, transforms) {
            var transform = _(transforms).reduce(function(arr, value, key) {
                    arr.push(key + '(' + value + ')');
                    return arr;
                }, []).join(' ');
            $el.css('-webkit-transform', transform)
               .css('-moz-transform', transform)
               .css('-ms-transform', transform)
               .css('transform', transform);
        };
        
        /**
         * Create a full URL for a document preview component
         * @param {string} base URL for the component (e.g. "styles.css")
         * @returns {string} complate path to component
         */
        var makeUrl = function(baseUrl) {
            return '/api/content/' + options.widgetData.id +
                   '/revisions/' + options.revisionId +
                   '/previews/' + baseUrl +
                   '?signature=' + options.widgetData.signature.signature +
                   '&expires=' + options.widgetData.signature.expires +
                   '&lastmodified=' + options.widgetData.signature.lastModified;
        };


        /////////////
        // Toolbar //
        /////////////
        
        /**
         * Refresh the Toolbar view
         */
        var refreshToolbar = function() {
            var zoomidx = _(ZOOMLEVELS).indexOf(state.zoomlevel);
            var pagenum = state.pagenum;
            var pagecnt = options.widgetData.previews.pageCount;
        
            // Enable/disable controls as appropriate
            $zoomOut.prop('disabled', (zoomidx <= 0));
            $zoomIn.prop('disabled', (zoomidx >= (ZOOMLEVELS.length - 1)));
            $nextPage.prop('disabled', (pagenum >= pagecnt));
            
            // Indicate the page that is currently shwoing
            $pageNumber.val(pagenum);
        };
        
        /**
         * Adjust display for a change in zoom level
         */
        var changeZoom = function() {
            /**
             * We need to adjust the scroll position after rescaling
             * the pages. Remember where we are now.
             */
            var curpage = pages[state.pagenum-1];
            var curTop = curpage.$el.position().top;
            var curZoom = $content.attr('data-zoom');

            // Scale all the pages
            _(pages).each(function(page) {
                zoomPage(page);
            });
            $content.attr('data-zoom', state.zoomlevel);

            // Restore the scroll position
            var newTop = (curTop / curZoom) * state.zoomlevel;
            $content.scrollTop($content.scrollTop() + curpage.$el.position().top - newTop);
        }

        /**
         * Toolbar event handlers
         */
        $zoomIn.on('click', function() {
            var zoomidx = _(ZOOMLEVELS).indexOf(state.zoomlevel);
            if (zoomidx < (ZOOMLEVELS.length - 1)) {
                state.zoomlevel = ZOOMLEVELS[++zoomidx];
                refreshToolbar();
                changeZoom();
            }
        });

        $zoomOut.on('click', function() {
            var zoomidx = _(ZOOMLEVELS).indexOf(state.zoomlevel);
            if (zoomidx > 0) {
                state.zoomlevel = ZOOMLEVELS[--zoomidx];
                refreshToolbar();
                changeZoom();
            }
        });

        $fullScreen.on('click', function() {
            activateFullscreen($content[0]);
        });

        $prevPage.on('click', function() {
            if (state.pagenum > 1) {
                state.pagenum--;
                refreshToolbar();
            }
            scrollToPage(pages[state.pagenum-1]);
        });

        $nextPage.on('click', function() {
            if (state.pagenum < options.widgetData.previews.pageCount) {
                state.pagenum++;
                refreshToolbar();
                scrollToPage(pages[state.pagenum-1]);
            }
        });

        $pageNumber.on('input', _(function() {
            /**
             * Note that we don't need to refresh the toolbar for
             * this event since the user is doing that for us.
             * We do limit the actual page number (though not
             * the one displayed) to the maximum that's actually
             * in the document.
             */
            pagenum = parseInt($pageNumber.val(), 10) || 1;
            pagenum = Math.min(pagenum, options.widgetData.previews.pageCount);
            pagenum = Math.max(pagenum, 1);
            if (pagenum !== state.pagenum) {
                state.pagenum = pagenum;
                scrollToPage(pages[pagenum-1]);
            }
        }).debounce(500));

        $pageNumber.on('blur', function() {
            /**
             * We need to refresh the toolbar in case the user
             * entered a value that exceeds the document page
             * count. We don't have to worry about the actual
             * state, though, since the pageChanged() handler
             * keeps that up-to-date and valid.
             */
            refreshToolbar();
        });


        //////////////////////
        // Document Content //
        //////////////////////

        /**
         * Start the process of loading a document page
         * @param {object} page to load
         */
        var loadPage = function(page) {
            /**
             * Make sure we have an element in which to place the
             * page content and that there isn't already a request
             * in progress.
             */
            if (page.$el && !page.deferred) {
                /**
                 * Ensure that the loading element is at least as
                 * high as the content container. Otherwise, if we
                 * try to scroll to the page before the content is
                 * loaded, then the browser will calculate the
                 * wrong scroll position.
                 */
                var $loadingContainer = $('<div />')
                    .addClass('text-center')
                    .css({
                        'clear': 'both',
                        'min-height': $content.height()
                    }
                );
                var $loader = $('<i />').addClass('icon-spinner icon-spin');
                // Create a text element that will be used for accessibility purposes
                var $a11yHelper = $('<span />').text('__MSG__LOADING__').addClass('oae-aural-text');
//                var $a11yHelper = $('<span />').text(oaeI18n.translate('__MSG__LOADING__')).addClass('oae-aural-text');
                // Add the accessibility helper to the loading animation and add the loading
                // animation to the loader container
                $loader.append($a11yHelper);
                $loadingContainer.append($loader);
                page.$el.append($loadingContainer);

                // Request the page
                page.deferred = $.ajax({
                    url: makeUrl('page.' + page.num + '.html'),
                    dataType: 'text'
                })
                .done(function(response) {
                    $loadingContainer.remove();
                    /**
                     * Wrap content so we can get its dimensions and scale it.
                     * The inner `<span>` gives us the natural dimensions of
                     * the page, and the outer `<div>` is what we'll transform
                     * when we scale it.
                     */
                    page.$inner = $('<span />')
                        .css({
                            position: 'relative',
                            display: 'inline-block'
                        })
                        .html(response);
                    page.$outer = $('<div />').append(page.$inner);
                    page.$el.append(page.$outer);
                    page.naturalHeight = page.$inner.outerHeight(true);
                    page.naturalWidth = page.$inner.outerWidth(true);
                    zoomPage(page);
                })
            }
        };
        
        /**
         * Scroll the content area to a specific page
         * @param {object} page to be shown
         */
        var scrollToPage = function(page) {
            // Make sure the page has (or is getting) content
            loadPage(page);
            // Scroll to the page's position
            $content.scrollTop($content.scrollTop() + page.$el.position().top);
        };
        
        /**
         * Zoom the page according to the document zoom level
         * @param {object} page to be scaled
         */
        var zoomPage = function(page) {
            if (page.$outer && page.naturalHeight && page.naturalWidth) {
                var scale = state.zoomlevel / 100;
                page.$el.css({
                    height: (page.naturalHeight * scale) + 'px',
                    width: (page.natrualWidth * scale) + 'px'
                });
                cssTransformOrigin(page.$outer, 'top left');
                cssTransform(page.$outer, {scale: scale});
                alignPage(page);
            }
        }
        
        /**
         * Align a page in the middle of its container
         * @param {object} page to align
         */
        var alignPage = function(page) {
            // Because of scaling, we can't rely on `margin: auto`
            if (page.$inner) {
                var containerWidth = isFullscreenActive() ? $(window).width() : $content.width();
                var contentWidth = page.$inner.width() * state.zoomlevel / 100;
                if (contentWidth < containerWidth) {
                    var left = (100 / state.zoomlevel) * (containerWidth - contentWidth) / 2;
                } else {
                    left = 5; // add some space (e.g. for border)
                }
                page.$inner.css('left', left + 'px');
            }
        }
        
        /**
         * Align all pages in the document
         */
        var alignAllPages = function() {
            _(pages).each(function(page) {
                alignPage(page);
            })
        }
        
        /**
         * Content area event handlers
         */
        $content.on('scroll', _(function() {
            var viewingPage = _.chain(pages).filter(function(pg) {
                return pg.$el.position().top <= 0;
            }).last().value();
            var pagenum = viewingPage ? viewingPage.num : 1;
            if (pagenum !== state.pagenum) {
                state.pagenum = pagenum;
                refreshToolbar();
            }
            // Check to see if we need to load more content
            if (pagenum < pages.length) {
                var pixelsRemaing = $content.prop('scrollHeight') - $content.height() - $content.scrollTop();
                if (pixelsRemaing < LOADTHRESHOLD) {
                    loadPage(pages[pagenum]);
                }
            }
        }).debounce(50));

        $(window).on('resize', _(function() {
            alignAllPages();
        }).debounce(50));

        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() {
            alignAllPages();
        });


        ////////////////////
        // Initialization //
        ////////////////////

        // Inject the document-specific style sheets
        _(['base.css','fancy.css','lines.css']).each(function(file) {
            $('head').append('<link rel="stylesheet" href="' + makeUrl(file) + '"/>');
        })
        
        // Create the objects and containers for all document pages
        _.chain(options.widgetData.previews.pageCount).range().each(function(idx) {
            var num = idx + 1; // Document page numbers start at 1
            var $el = $('<div />')
                .addClass('documentpreview-content-page')
                .attr('data-pagenum', num);
            $content.append($el);
            pages.push({
                num: num,
                $el: $el
            });
        });
        // Update the toolbar to reflect initial state
        $totalPages.text(options.widgetData.previews.pageCount);
        if (hasFullscreen()) {
            $fullScreen.show();
        }
        refreshToolbar();
        
        // Set up the content container
        $content.attr('data-zoom', state.zoomlevel);
        scrollToPage(pages[state.pagenum-1]);

    };
});
