/*!
 * Copyright 2013 Apereo Foundation (AF) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

// This module (along with its associated assets) implements a document
// preview widget. The widget displays the content of an uploaded
// document as individual pages within a section of the web page. It
// provides controls to allow users to advance to specific document
// pages and to zoom in or out to show detail. The widget also supports
// a full-screen mode with browsers that provide the HTML5 full screen
// API.
//
// ## Creating a Module
//
// The module's creation function accepts three parameters
//
// * `uid`: A unique identifier for this particular object. (In general,
//   a web page may include multiple instances of any particular
//   widget, thought this may be less likely for the document
//   preview widget. The `uid` parameter is passed to all widgets,
//   however, to provide a unique ID.)
// * `showSettings`: Not currently used by this widget.
// * `widgetData`: Information about the document to preview. The widget
//   uses several properties of this object:
//   * `id`: Unique identifier for the document to preview.
//   * `latestRevisionId`: Unique identifier for the latest revision of
//     the document. For now, that's the one we're previewing.
//   * `previews.pageCount`: Total number of pages in the document.
//   * `signature.signature`: Digital signature that grants access to the
//     document.
//   * `signature.expires`: Time at which signature (granting access) expires.
//   * `signature.lastModified`: Last modification time of signature that
//     grants access to document.
//
// ## Removing a Module
//
// Although the standard OAE widget doesn't normally include a `delete`
// method, we want to be good citizens and at least provide the option
// to clean up after ourselves. If the `uid` parameter is undefined,
// then we'll take that as a request to delete the widget. The actual
// deletion would be handled by the widget loader, but we do need to
// clean up some stuff that the loader won't know about.
//
// ## API Dependencies
//
// The module relies on the OAE core API to deliver the actual document
// preview content. That content includes several CSS style sheets to
// inject into the web page, as well as HTML for the document pages. All
// API requests include signature parameters added as a query string,
// e.g.,
//
//     ?signature={sig}&expires={exp}&lastmodified={mod}
//
// where
//
// * `{sig}` is the `signature.signature` property of the `widgetData`.
// * `{exp}` is the `signature.expires` property of the `widgetData`.
// * `{mod}` is the `signature.lastModified` property of the `widgetData`.
//
// The extra CSS style sheets are
//
// * `/api/content/{docId}/revisions/{revId}/previews/base.css`
// * `/api/content/{docId}/revisions/{revId}/previews/fancy.css`
// * `/api/content/{docId}/revisions/{revId}/previews/lines.css`
//
// where
//
// * `{docId}` is the unique identifier for the document (the `id`
//   property of `widgetData`.
// * `{revId}` is the identifier for the latest revision (the
//   `lastRevisionId` property of `widgetData`.
//
// The document's pages are themselves accessed via the API as
//
// * `/api/content/{docId}/revisions/{revId}/previews/page.{pageNum}.html`
//
// where `{pageNum]` is the specific document page required.
//
// ## Document Format
//
// TDB

define(['jquery', 'underscore', 'oae.core'], function($, _, oae) {

    // ## Constants

    // We define sensible (well, as sensible as possible) defaults
    // for all the parameters and options that the widget requires.
    // If/when there's a more robust error handling framework in
    // place, we should probably re-visit this approach and throw
    // an error when a required property isn't present. For now,
    // though, throwing an error wouldn't accomplish anything
    // useful so we'll muddle along.
    var DEFAULTOPTIONS = {
        showSettings: {},
        widgetData: {
            id: 0,
            latestRevisionId: 0,
            previews: {
                pageCount: 0
            },
            signature: {
                signature: '',
                expires:   '',
                lastModified: ''
            }
        }
    };
    var DEFAULTSTATE = {
        zoomlevel: 100,
        pagenum: 1
    }
    
    // What zoom levels do we support, sorted in order of increasing zoom levels.
    var ZOOMLEVELS = [50, 75, 90, 100, 110, 125, 150, 200];

    // ## Private Attributes

    // More information on individual attributes when they're
    // initialized in the `init()` function.
    var options,
        state,
        styleSheets = [],
        controller;

    // ## Private Member Functions

    // ### Generic Utilties
    
    // #### hasFullscreen()
    
    // `hasFullscreen()` returns a boolean indication of whether or
    // not the browswer supports a version of the HTML5 fullscreen
    // API.
    var hasFullscreen = function() {
        var el = $('html')[0];
        return el.requestFullscreen
            || el.mozRequestFullScreen
            || el.webkitRequestFullscreen;
    };
    
    // #### activateFullscreen()
    
    // `activateFullscreen()` enables full screen view of an element.
    var activateFullscreen = function(el) {
        if (el.requestFullscreen) {
          el.requestFullscreen();
        } else if (el.mozRequestFullScreen) {
          el.mozRequestFullScreen();
        } else if (el.webkitRequestFullscreen) {
          el.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
        // TODO: Something sensible if regular fullscreen isn't available.
    };

    // #### saveState()

    // `saveState()` preserves a copy of the current state for this
    // document so it can be restored if the user returns to the
    // same document later.
    var saveState = function() {
        // For now, we're only using HTML5 local storage. If we need
        // to support legacy browsers and this feature is essential,
        // we could fall back to cookies.
        if (localStorage) {
            localStorage.setItem(
                'documentpreview-' + options.widgetData.id,
                JSON.stringify(state)
            );
        }
    };

    // #### getSavedState()

    // `getSavedState()` retrieves the saved state if one is available;
    // otherwise it returns an empty object.
    var getSavedState = function() {
        var savedState = null;
        // As above, we're only using HTML5 local storage for now.
        if (localStorage) {
            savedState = localStorage.getItem(
                'documentpreview-' + options.widgetData.id
            );
        }
        return _.isNull(savedState) ? {} : JSON.parse(savedState);
    };

    // #### makeUrl()
    
    // `makeUrl()` adds the api prefix and signature parameters to a
    // URL Its input is the base URL, and it returns the augmented URL.
    // Note that we're blithely assuming the appropriate properties
    // exist in the `options` object. (We defined defaults, so they
    // should be present, even if they're not exactly functional.)
    
    var makeUrl = function(baseUrl) {
        return '/api/content/' + options.widgetData.id
             + '/revisions/' + options.revisionId
             + '/previews/' + baseUrl
             + '?signature=' + options.widgetData.signature.signature
             + '&expires=' + options.widgetData.signature.expires
             + '&lastmodified=' + options.widgetData.signature.lastModified;
    };

    // ## Private Classes
    
    // ### Toolbar Class
    
    var Toolbar = function($parent) {
        var $zoomIn     = $parent.find('.dp-zoom-in'),
            $zoomOut    = $parent.find('.dp-zoom-out'),
            $fullScreen = $parent.find('.dp-full-screen'),
            $prevPage   = $parent.find('.dp-page-prev'),
            $pageNumber = $parent.find('.dp-page-num'),
            $totalPages = $parent.find('.dp-page-count'),
            $nextPage   = $parent.find('.dp-page-next');

        // `getZoomIndex()` finds the index within the ZOOMLEVELS array
        // of a given value. If there is no exact value, it finds the
        // closest one. We need to account for the case of no exact
        // match because we're saving zoom levels in, e.g. HTML5
        // local storage. If the widget is updated with a new set
        // of zoom levels, a user may still have a value from the
        // older version. Since we can't do an exact match, we'll
        // do the best we can.
        var getZoomIndex = function(zoom) {
            var closest = _(ZOOMLEVELS).min(function(level) {
                return Math.abs(level - zoom);
            })
            return _(ZOOMLEVELS).indexOf(closest);
        };
        
        // `fixZoomLevel()` ensures that the zoom level is valid. This
        // functionality may be needed if the user is returning to a
        // page using a newer version of the widget with updated zoom
        // levels.
        var fixZoomLevel = function() {
            state.zoomlevel = ZOOMLEVELS[getZoomIndex(state.zoomlevel)];
        };

        // `fixPageNum()` ensures that the current page number is valid.
        // This functionality may be needed if the user is returning to a
        // newer revision of the document that has fewer pages than the
        // prior revision.
        var fixPageNum = function() {
            if (state.pagenum > options.widgetData.previews.pageCount) {
                state.pagenum = options.widgetData.previews.pageCount;
            }
        };

        // `setEnableState()` sets the enable/disable state of an
        // element in the toolbar.
        var setEnableState = function($el, cond) {
            if (cond) {
                $el.removeClass('disabled');
            } else {
                $el.addClass('disabled');
            }
        }

        // `refreshView()` makes sure the toolbar display reflects the
        // current user state.
        var refreshView = function() {
            var zoomidx,
                pagenum,
                pagecnt;
            
            // Make sure the zoom level and page number values are valid.
            fixZoomLevel();
            fixPageNum();
            
            zoomidx = getZoomIndex(state.zoomlevel);
            pagenum = state.pagenum;
            pagecnt = options.widgetData.previews.pageCount;

            // Enable/disable controls as appropriate
            setEnableState($zoomOut, (zoomidx > 0));
            setEnableState($zoomIn, (zoomidx < (ZOOMLEVELS.length - 1)));
            setEnableState($prevPage, (pagenum > 1));
            setEnableState($nextPage, (pagenum < pagecnt));
            
            // What page are we currently viewing?
            $pageNumber.val(pagenum);
            
            // Set the total page count in the toolbar. In theory this
            // should only be needed once, but just in case we ever
            // support dynamic documents (e.g. live edits or annotations)
            // go ahead and update it as well.
            $totalPages.text(pagecnt);
        };

        // Event handlers
        var zoomIn = function(evt) {
            evt.preventDefault();
            var zoomidx = getZoomIndex(state.zoomlevel);
            if (zoomidx < (ZOOMLEVELS.length - 1)) {
                state.zoomlevel = ZOOMLEVELS[++zoomidx];
                saveState();
                refreshView();
                $parent.trigger('zoomChanged');
            }
        };
        var zoomOut = function(evt) {
            evt.preventDefault();
            var zoomidx = getZoomIndex(state.zoomlevel);
            if (zoomidx > 0) {
                state.zoomlevel = ZOOMLEVELS[--zoomidx];
                saveState();
                refreshView();
                $parent.trigger('zoomChanged');
            }
        };
        var fullScreen = function(evt) {
            evt.preventDefault();
            $parent.trigger('fullScreen');
        };
        var prevPage = function(evt) {
            evt.preventDefault();
            if (state.pagenum > 0) {
                state.pagenum--;
                saveState();
                refreshView();
                $parent.trigger('pageChanged');
            }
        };
        var nextPage = function(evt) {
            evt.preventDefault();
            if (state.pagenum < options.widgetData.previews.pageCount) {
                state.pagenum++;
                saveState();
                refreshView();
                $parent.trigger('pageChanged');
            }
        };
        var pageChanged = function(evt) {
            evt.preventDefault();
            // This function handles changes in the page `<input>`
            // that take place as the user is typing in it.
            // Note that we don't need to refresh the toolbar for
            // this event since the user is doing that for us.
            // We do limit the actual page number (though not
            // the one displayed) to the maximum that's actually
            // in the document.
            state.pagenum = $pageNumber.val();
            fixPageNum();
            $parent.trigger('pageChanged');
        };
        var newPage = function(evt) {
            evt.preventDefault();
            // In this case, we do need to refresh the toolbar
            // to accomodate user input that exceeds the actual
            // document page count. As this function handles
            // blur events, we can safely change that value
            // without confusing users by changing while they're
            // typing.
            state.pagenum = $pageNumber.val();
            fixPageNum();
            refreshView();
            $parent.trigger('pageChanged');
        };

        // Now that our event handlers are defined, here's
        // the code to enable them.
        var enableHandlers = function() {
            $zoomIn.on('click', zoomIn);
            $zoomOut.on('click', zoomOut);
            $fullScreen.on('click', fullScreen);
            $prevPage.on('click', prevPage);
            $nextPage.on('click', nextPage);
            $pageNumber.on('input', _(pageChanged).debounce(500));
            $pageNumber.on('blur', newPage);
        };

        // And the complement to disable event handling.
        var disableHandlers = function() {
            $zoomIn.off();
            $zoomOut.off();
            $fullScreen.off();
            $prevPage.off();
            $nextPage.off();
            $pageNumber.off();
        };
        
        // Initialization code. First check to see if full
        // screen mode is available. Then efresh the view to get
        // it up and enable the event handlers.
        if (hasFullscreen()) {
            $fullScreen.addClass('supported');
        }
        refreshView();
        enableHandlers();

        return {
            refresh: function() {
                refreshView();
                return this;
            },
            enable: function() {
                enableHandlers();
                return this;
            },
            disable: function() {
                disableHandlers();
                return this;
            }
        };
        
    };
    
    // ### PreviewStylesheet Class
    
    // The `PreviewStylesheet` class models a CSS stylesheet
    // (there are several) that the document preview processor
    // creates for a document.
    
    var PreviewStylesheet = function(filename) {
        var file = filename,
            url = makeUrl(file),
            contents = '',
            domNode = null,
            deferred = null;

        var addToPage = function() {
            // Direct DOM manipulation is fastest and most widely
            // supported, so we'll use it to create a style node.
            domNode = domNode || document.createElement('style');
            domNode.type = 'text/css';
            
            // To add the actual styles, we handle IE first (of course)
            // since it's unique.
            if (domNode.styleSheet) {
                domNode.styleSheet.cssText = contents;
            } else {
                // Non-IE browsers let us just append the styles to the
                // node. Note that (all/some?) versions of Chrome don't
                // support innerHTML like everyone else so we'll go with
                // a plain old text node.
                domNode.appendChild(document.createTextNode(contents));
            }
            
            // Styles are added to the head of the document. All
            // modern browsers support `document.head` but we'll
            // be nice and handle older browsers as well.
            var head = document.head || document.getElementsByTagName('head')[0];
            head.appendChild(domNode);
        };
        
        var removeFromPage = function() {
            if (domNode && domNode.parentNode) {
                domNode.parentNode.removeChild(domNode);
            }
        };

        return {
            add: function() {
                // Only do something if we haven't already requested
                // the content or if a previous request failed.
                if (!deferred || (deferred.state === 'rejected')) {
                    deferred = $.ajax({
                        url: url,
                        dataType: 'text'
                    })
                    .done(function(response) {
                        contents = response;
                        addToPage();
                    })
                }
                return this;
            },
            remove: function() {
                removeFromPage();
                return this;
            },
            getDeferred: function() {
                return deferred;
            },
            getFilename: function() {
                return file;
            }
        }
    };

    // ### PreviewPage Class

    // The `PreviewPage` class models a single document
    // page that's part of the preview.

    var PreviewPage = function(pageNum) {
        var num = pageNum,
            url = makeUrl('page.' + num + '.html'),
            deferred = null,
            $el = $('<div>')
                .addClass('dp-content-page')
                .attr('data-pagenum', num),
            naturalHeight = false,
            margins = false,
            loaded = false,
            inserted = false;
          
        // Save the natural height of the page when it's available
        // so we can use that value for scaling.
        var saveHeight = function() {
            // Becaues CSS rules may effect the height of the page,
            // we can only get a value after the page has been
            // loaded and inserted in the DOM. And, of course,
            // we only need to get this value once.
            if (!naturalHeight && loaded && inserted) {
                var $child = $el.find('>:first-child');
                naturalHeight = $child.height();
                margins = $child.outerHeight(true) - naturalHeight;
            }
        };

        // To eliminate any overlap of pages or extra whitespace
        // between them, we need to manually set the height of
        // the page based on the current zoom level.
        var adjustZoom = function() {
            // Only do this if we know the natural height of the page.
            if (naturalHeight) {
                $el.css(
                    'height',
                    Math.ceil(margins + naturalHeight*state.zoomlevel/100) + 'px'
                );
            }
        };

        return {
            retrieve: function() {
                // Only do something if we haven't already requested
                // the content or if a previous request failed.
                if (!deferred || (deferred.state === 'rejected')) {
                    $el.addClass('loading');
                    deferred = $.ajax({
                        url: url,
                        dataType: 'text'
                    })
                    .done(function(response) {
                        $el.html(response);
                        $el.removeClass('loading');
                        loaded = true;
                        saveHeight();
                        adjustZoom();
                    })
                }
                return this;
            },
            insertIn: function($parent) {
                // Make sure the element isn't already in the DOM before
                // we go to any trouble.
                if ($parent.has($el).length === 0) {
                    // We need to insert the page in the correct order
                    // within the $parent. Scan through what's already
                    // there looking for any pages with lower page
                    // numbers.
                    var $pages = $parent.find('.dp-content-page')
                        .filter(function() {
                            return $(this).attr('data-pagenum') < num;
                        });

                    // If there is already at least one page with a lower
                    // page number, insert after the last of them.
                    // Otherwise insert at the beginning.
                    if ($pages.length > 0) {
                        $pages.last().after($el);
                    } else {
                        $parent.prepend($el);
                    }
                    inserted = true;
                    saveHeight();
                    adjustZoom();
                }
                return this;
            },
            zoomChanged: function() {
                adjustZoom();
            },
            getMargins: function() {
                return margins ? margins : 0;
            },
            detach: function() {
                $el.detach();
                return this;
            },
            getDeferred: function() {
                return deferred;
            },
            getPageNum: function() {
                return num;
            }
        };
    };

    // ### PreviewController Class

    // The `PreviewController` class coordinates the operation of the
    // toolbar and the content pages.

    var PreviewController = function($parent) {
        var $content = $parent.find('.dp-content'),
            toolbar = new Toolbar($parent),
            pages = [];
        
        var updateZoom = function() {
            $content.attr('data-zoom', state.zoomlevel)
            _(pages).each(function(page){
                page.zoomChanged();
            })
        };

        var gotoPreviewPage = function() {
            var num = state.pagenum;
            if ((num > 0) &&
                (num <= options.widgetData.previews.pageCount)) {
                // Scroll to the desired page.
                // TODO: Adjust for zoom levels < 100%
                $content.scrollTop(
                    $content.scrollTop() +
                    $content.find('.dp-content-page[data-pagenum='
                        + num
                        + ']').position().top
                        - Math.ceil(pages[num-1].getMargins()/2)
                );
            }
        };

        var fullScreen = function() {
            activateFullscreen($content[0]);
        };
        
        var contentScrolled = function() {
            // For now, all we're doing is monitoring scrolling to keep
            // track of the current page in view. Eventually we may want
            // to handle a more sophisticated lazy loading strategy.
            var pgNums = _.range(1, options.widgetData.previews.pageCount+1);
            
            // Find out which page numbers are above or at the top of the
            // content container.
            var viewed = _(pgNums).filter(function(num) {
                        return $content.find('.dp-content-page[data-pagenum='
                            + num
                            + ']').position().top <= pages[num-1].getMargins();
                    });
            // Generally, the last page in this list is the one that the
            // user is viewing.
            var topPage = _(viewed).last();

            // If the top page isn't the same as the page considered to be
            // preferred, then update things.
            if (state.pagenum !== topPage) {
                state.pagenum = topPage;
                saveState();
                toolbar.refresh();
            }
        };
    
        // Initialize the objects we use to track document pages.
        _.chain(options.widgetData.previews.pageCount).range().each(function(idx) {
            var page = new PreviewPage(idx+1)
            // Eventually we may want to manage memory more intelligently to
            // avoid overloading constrained browsers, but for now go ahead and
            // fetch all the pages. Same deal for adding content to the DOM.
            page.retrieve().insertIn($content);
            pages.push(page);
        });

        // Update the zoom level and move to the content page of the user's choice
        // Once we're sure that enough of the content has been loaded so that
        // heights may be calculated and positions may be scrolled to. For now
        // that means all pages up to (and including) the preferred page are
        // loaded.
        $.when.apply($,
            _.chain(pages)
                .filter(function(page, idx) {
                    return idx < state.pagenum;
                })
                .map(function(page) {
                    return page.getDeferred()
                })
                .value()
            )
            .then(function() {
                // We need to give the browser a bit of time to paint the DOM
                // so it can calculate values.
                setTimeout(function() {
                    updateZoom();
                    gotoPreviewPage();
                }, 100);
            });
        
        // Listen for custom events indicating toolbar actions
        $parent.on('zoomChanged', function() {
                updateZoom();
            }).on('pageChanged', function() {
                gotoPreviewPage();
            }).on('fullScreen', function() {
                fullScreen();
            })
            
        // Keep track of the scroll position so we can update the toolbar
        $content.on('scroll', function() {
            contentScrolled();
        });
        
        return {
            enable: function() {
                return this;
            },
            disable: function() {
                toolbar.disable();
                return this;
            }
        };
    };
    
    // ### Functions Controlling Widget Lifetime

    // #### init()
    //
    // `init()` initializes the widget object. Its parameters
    // are the unique widget identifer and the widgetData object
    // passed on object creation

    var init = function(uid, showSettings, widgetData) {

        // Save local copies of the input parameters
        options = $.extend(true, {},
            DEFAULTOPTIONS,
            {uid: uid},
            {showSettings: showSettings},
            {widgetData: widgetData}
        );

        // Until there's an API to get anything else, we'll use
        // the last revision ID as the one to display.
        options.revisionId = options.widgetData.latestRevisionId;

        // Initialize the variables that view state.
        state = $.extend(true, {}, DEFAULTSTATE, getSavedState());

        // Rendering the preview correctly relies on several
        // additional CSS style sheets. We can keep track of them
        // here in case there's ever a need to remove them (e.g.
        // if the widget is removed from the page without a page
        // refresh).
        _(['base.css','fancy.css','lines.css']).each(function(file) {
            var styles = new PreviewStylesheet(file);
            // Add the styles to the page.
            styles.add();
            styleSheets.push(styles);
        });
        
        // Find the element that's acting as the root
        // for the widget. This is where the unique identifier
        // comes into play. The widget will be installed inside
        // of an HTML element with the unique ID as an `id`
        // attribute.
        var $rootel = $('#' + uid);

        // The widget itself should be created within this uniquely
        // identified root element. Note that we use a class name
        // for the container to allow for the possibility of multiple
        // document preview widgets on the page.
        var $container = $rootel.find('.documentpreview-container');

        // With the preliminaries out of the way, go ahead and
        // create the controller object. It will handles things
        // from there.
        controller = new PreviewController($container);
    };

    // #### remove()
    //
    // `remove()` prepares the widget for removal from the page.

    var remove = function() {
        // Remove the CSS style sheets we added to the page.
        _(styleSheets).each(function(styles) {
            styles.remove();
        });
        controller.disable();
    };

    // ## Returned Object
    //
    // Return the object that controls the document preview.

    return function(uid, showSettings, widgetData) {

        if (_(uid).isUndefined()) {
            remove();
        } else {
            // We've got a `uid` defined, so go ahead and
            // initialize the widget.
            init(uid, showSettings, widgetData);
        }
        return {
            delete: remove
        }
    };
});
